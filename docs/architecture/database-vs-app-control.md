# アプリケーション vs データベース制御の設計判断

## 現在の実装状況

| 処理 | 制御場所 | 実装方法 |
|------|---------|---------|
| profiles作成 | **データベース側** | トリガー (on_auth_user_created) |
| 世帯作成 | **アプリケーション側** | services/households.ts |
| household_members追加 | **アプリケーション側** | services/households.ts |

## データベース側での制御（トリガー・RPC関数）

### ✅ メリット

1. **データ整合性の保証**
   - どのクライアントからでも同じロジックが適用される
   - データベースレベルで一貫性が保証される

2. **ロジックの一元管理**
   - Web、モバイル、管理画面など複数クライアントがある場合、重複を避けられる

3. **パフォーマンス**
   - データベース内で完結するため、ネットワークラウンドトリップが減る
   - 1回のクエリで複雑な処理が可能

4. **セキュリティ**
   - クライアント側のバグの影響を受けにくい
   - 重要な制約をバイパスされるリスクが低い

### ❌ デメリット

1. **RLSとの相互作用が複雑**
   - トリガー内で `auth.uid()` が取得できるかどうか不確実
   - RLSポリシーのチェックタイミングとトリガーの実行順序の問題
   - **今回はまさにこれが問題だった**

2. **デバッグが困難**
   - エラーメッセージが不明瞭
   - ログが見づらい
   - 実行コンテキストの把握が難しい

3. **SQLで書く必要がある**
   - チーム全員がSQLに精通している必要がある
   - TypeScriptの型安全性の恩恵を受けられない

4. **テストが難しい**
   - ユニットテストを書きづらい
   - モックが困難

5. **開発速度**
   - 修正のたびにSupabase Studioでマイグレーション実行が必要
   - ローカル開発環境のセットアップが複雑

## アプリケーション側での制御

### ✅ メリット

1. **コードの可読性**
   - TypeScript/JavaScriptで書ける
   - ビジネスロジックが明示的
   - IDEのサポート（補完、型チェック）

2. **デバッグが容易**
   - console.logで詳細なログが取れる
   - ブラウザの開発者ツールで確認できる
   - エラーハンドリングが柔軟

3. **テストが書きやすい**
   - Vitestでユニットテストが書ける
   - Supabaseクライアントをモックできる
   - TDDが実践しやすい

4. **開発速度が速い**
   - コード修正→ブラウザリロードだけで確認できる
   - Supabaseマイグレーション不要

5. **RLSとの競合を避けやすい**
   - 明示的にデータを設定するため、RLSチェックが分かりやすい

6. **ユーザーへのフィードバック**
   - 詳細なエラーメッセージを返せる
   - 処理の進捗を表示できる

### ❌ デメリット

1. **複数クライアントでのロジック重複**
   - Web、モバイルアプリで同じロジックを実装する必要がある
   - ただし、MVPでは1クライアントのみなので問題ない

2. **データ不整合の可能性**
   - クライアント側のバグでロジックが実行されない可能性
   - ただし、RLSで最低限の保護は可能

3. **トランザクション管理**
   - 複数のINSERT/UPDATEを1トランザクションにまとめるのが難しい
   - Supabase Clientからはトランザクション制御が限定的

4. **パフォーマンス**
   - 複数のクエリが必要な場合、ネットワークラウンドトリップが増える

## 🎯 推奨事項

### 現在のMVP段階では

**✅ アプリケーション側での制御が適切**

理由：
- 開発スピードが最優先
- デバッグが容易で問題解決が早い
- 仕様変更に柔軟に対応できる
- クライアントは1つ（Web）のみ
- RLSとの競合を避けられる

### 例外：データベース側で制御すべきもの

以下は**データベース側（トリガー・制約）**で実装すべき：

1. **技術的な整合性**
   - ✅ profiles作成（外部キー制約を満たすため）
   - ✅ updated_atの自動更新
   - ✅ created_byの自動設定（可能であれば）

2. **セキュリティに関わる重要なチェック**
   - ✅ RLSポリシー（最低限の保護）
   - ✅ CHECK制約（amount > 0 など）

3. **監査ログ**
   - ✅ created_at, updated_atの自動設定

### 将来的な改善（MVP後）

1. **サーバーサイド実装への移行**
   ```typescript
   // Next.js Server Actions / API Routes
   'use server'

   export async function createHousehold(name: string) {
     const supabase = createClient({
       serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY
     })

     // ここでトランザクション的な処理が可能
     // RLSをバイパスできる
   }
   ```

2. **重要なビジネスロジックをRPC関数として実装**
   ```sql
   CREATE FUNCTION public.create_household_with_owner(
     household_name TEXT,
     owner_id UUID
   ) RETURNS UUID AS $$
   DECLARE
     new_household_id UUID;
   BEGIN
     -- トランザクション内で処理
     INSERT INTO households (name, owner_user_id)
     VALUES (household_name, owner_id)
     RETURNING id INTO new_household_id;

     INSERT INTO household_members (household_id, user_id, role)
     VALUES (new_household_id, owner_id, 'owner');

     RETURN new_household_id;
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER;
   ```

3. **複数クライアント対応**
   - 共通のビジネスロジックをnpmパッケージ化
   - またはGraphQL/tRPCで共通API化

## 📊 判断基準

| 要素 | データベース側 | アプリケーション側 |
|------|--------------|------------------|
| データ整合性が最重要 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 開発スピード優先 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| デバッグ容易性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 複数クライアント | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| テスト容易性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| RLSとの相性 | ⭐⭐ | ⭐⭐⭐⭐ |
| パフォーマンス | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

## 🎬 結論

### 現在のMVP

**アプリケーション側での制御が正解です。**

理由：
- 開発効率が圧倒的に高い
- デバッグが容易
- RLSとの競合を避けられる
- MVP段階ではパフォーマンスよりも開発スピードが重要

### ただし

以下は**データベース側に残す**：
- ✅ profiles自動作成トリガー（技術的な要件）
- ✅ RLSポリシー（セキュリティの最後の砦）
- ✅ CHECK制約（データの妥当性）

### MVP卒業後

以下を検討：
1. Next.js Server Actions/API Routesへの移行
2. 重要なビジネスロジックのRPC関数化
3. 複数クライアント対応時の共通化戦略

---

**現在の実装は適切です。自信を持って進めてください！**

🤖 Generated with Claude Code
